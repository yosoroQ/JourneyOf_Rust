# Rust 之旅 - 核心概念

* 经典的新手编程问题：猜猜看游戏。它是这么工作的：程序将会随机生成一个 1 到 100 之间的随机整数。接着它会请玩家猜一个数并输入，然后提示猜测是大了还是小了。如果猜对了，它会打印祝贺信息并退出。
* 涉及概念：变量、基本类型、函数、注释和控制流

# 关键字（keyword）

* https://rust.bootcss.com/appendix-01-keywords.html

## 目前正在使用的关键字

如下关键字目前有对应其描述的功能。

- `as` - 强制类型转换，消除特定包含项的 trait 的歧义，或者对 `use` 和 `extern crate` 语句中的项重命名
- `break` - 立刻退出循环
- `const` - 定义常量或不变裸指针（constant raw pointer）
- `continue` - 继续进入下一次循环迭代
- `crate` - 链接（link）一个外部 **crate** 或一个代表宏定义的 **crate** 的宏变量
- `dyn` - 动态分发 trait 对象
- `else` - 作为 `if` 和 `if let` 控制流结构的 fallback
- `enum` - 定义一个枚举
- `extern` - 链接一个外部 **crate** 、函数或变量
- `false` - 布尔字面值 `false`
- `fn` - 定义一个函数或 **函数指针类型** (*function pointer type*)
- `for` - 遍历一个迭代器或实现一个 trait 或者指定一个更高级的生命周期
- `if` - 基于条件表达式的结果分支
- `impl` - 实现自有或 trait 功能
- `in` - `for` 循环语法的一部分
- `let` - 绑定一个变量
- `loop` - 无条件循环
- `match` - 模式匹配
- `mod` - 定义一个模块
- `move` - 使闭包获取其所捕获项的所有权
- `mut` - 表示引用、裸指针或模式绑定的可变性
- `pub` - 表示结构体字段、`impl` 块或模块的公有可见性
- `ref` - 通过引用绑定
- `return` - 从函数中返回
- `Self` - 实现 trait 的类型的类型别名
- `self` - 表示方法本身或当前模块
- `static` - 表示全局变量或在整个程序执行期间保持其生命周期
- `struct` - 定义一个结构体
- `super` - 表示当前模块的父模块
- `trait` - 定义一个 trait
- `true` - 布尔字面值 `true`
- `type` - 定义一个类型别名或关联类型
- `unsafe` - 表示不安全的代码、函数、trait 或实现
- `use` - 引入外部空间的符号
- `where` - 表示一个约束类型的从句
- `while` - 基于一个表达式的结果判断是否进行循环

## 保留做将来使用的关键字

如下关键字没有任何功能，不过由 Rust 保留以备将来的应用。

- `abstract`
- `async`
- `await`
- `become`
- `box`
- `do`
- `final`
- `macro`
- `override`
- `priv`
- `try`
- `typeof`
- `unsized`
- `virtual`
- `yield`

## 原始标识符

原始标识符（Raw identifiers）允许你使用通常不能使用的关键字，其带有 `r#` 前缀。

例如，`match` 是关键字。如果尝试编译如下使用 `match` 作为名字的函数：

```rust
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

会得到这个错误：

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

该错误表示你不能将关键字 `match` 用作函数标识符。你可以使用原始标识符将 `match` 作为函数名称使用：

文件名: src/main.rs

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

此代码编译没有任何错误。注意 `r#` 前缀需同时用于函数名定义和 `main` 函数中的调用。

原始标识符允许使用你选择的任何单词作为标识符，即使该单词恰好是保留关键字。

# 变量和可变性

* **变量默认是不可改变的（immutable）**
* 这是推动你以充分利用 Rust 提供的安全性和简单并发性来编写代码的众多方式之一。不过，你仍然可以使用可变变量。让我们探讨一下 Rust 拥抱不可变性的原因及方法，以及何时你不想使用不可变性。
* 当变量不可变时，一旦值被绑定一个名称上，你就不能改变这个值。为了对此进行说明，使用 `cargo new variables` 命令在 *projects* 目录生成一个叫做 *variables* 的新项目。
* 接着，在新建的 *variables* 目录，打开 *src/main.rs* 并将代码替换为如下代码，这些代码还不能编译：

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

* 保存并使用 `cargo run` 运行程序。应该会看到一条错误信息，如下输出所示：

![image-20231015231244941](http://qny.expressisland.cn/dian/image-20231015231244941.png)

* 这个例子展示了编译器如何帮助你找出程序中的错误。虽然编译错误令人沮丧，但那只是表示程序不能安全的完成你想让它完成的工作；并 **不能** 说明你不是一个好程序员！经验丰富的 Rustacean 们一样会遇到编译错误。

  错误信息指出错误的原因是 `不能对不可变变量 x 二次赋值`（`cannot assign twice to immutable variable x`），因为你尝试对不可变变量 `x` 赋第二个值。

* 在尝试改变预设为不可变的值时，产生编译时错误是很重要的，因为这种情况可能导致 bug。如果一部分代码假设一个值永远也不会改变，而另一部分代码改变了这个值，第一部分代码就有可能以不可预料的方式运行。不得不承认这种 bug 的起因难以跟踪，尤其是第二部分代码只是 **有时** 会改变值。

* Rust 编译器保证，如果声明一个值不会变，它就真的不会变。这意味着当阅读和编写代码时，不需要追踪一个值如何和在哪可能会被改变，从而使得代码易于推导。

* 不过可变性也是非常有用的。变量只是默认不可变；正如在第二章所做的那样，你可以在变量名之前加 `mut` 来使其可变。除了允许改变值之外，`mut` 向读者表明了其他代码将会改变这个变量值的意图。

## 通过 `mut`进行修改

* 通过 `mut`，允许把绑定到 `x` 的值从 `5` 改成 `6`。在一些情况下，你会想用可变变量，因为与只用不可变变量相比，它会让代码更容易编写。

* 除了防止出现 bug 外，还有很多地方需要权衡取舍。

* 例如，使用大型数据结构时，适当地使用可变变量，可能比复制和返回新分配的实例更快。对于较小的数据结构，总是创建新实例，采用更偏向函数式的编程风格，可能会使代码更易理解，为可读性而牺牲性能或许是值得的。

```rust
fn main() {
    //通过 `mut`，允许把绑定到 `x` 的值从 `5` 改成 `6`
    let mut x = 5;
    println!("The value of mut x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

![image-20231015232114436](http://qny.expressisland.cn/dian/image-20231015232114436.png)

# 变量和常量的区别

不允许改变值的变量：**常量**（*constants*），类似于不可变变量，常量是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别。

首先，不允许对常量使用 `mut`。常量不光默认不能变，它总是不能变。

声明常量使用 `const` 关键字而不是 `let`，并且 *必须* 注明值的类型。

常量可以在任何作用域中声明，包括全局作用域，这在一个值需要被很多部分的代码用到时很有用。

最后一个区别是，常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。

## 声明常量的例子

* 它的名称是 `MAX_POINTS`，值是 100000。
* Rust 常量的命名规范是使用下划线分隔的大写字母单词，并且可以在数字字面值中插入下划线来提升可读性。

```rust
const MAX_POINTS: u32 = 100_000;
```

* 在声明它的作用域之中，常量在整个程序生命周期中都有效，这使得常量可以作为多处代码使用的全局范围的值，例如一个游戏中所有玩家可以获取的最高分或者光速。

* 将遍布于应用程序中的硬编码值声明为常量，能帮助后来的代码维护人员了解值的意图。

* 如果将来需要修改硬编码值，也只需修改汇聚于一处的硬编码值。

# 隐藏（Shadowing）

* 在猜猜看游戏中，我们可以定义一个与之前变量同名的新变量，而新变量会 **隐藏** 之前的变量。
* Rustacean 们称之为第一个变量被第二个 **隐藏** 了，这意味着使用这个变量时会看到第二个值。
* 可以用相同变量名称来隐藏一个变量，以及重复使用 `let` 关键字来多次隐藏。

```rust
fn main() {
    let x = 5;
    let x = x + 1;
    let x = x * 2;

    println!("The value of x is: {}", x);
    //The value of x is: 12
}
```

* 这个程序首先将 `x` 绑定到值 `5` 上。
* 接着通过 `let x =` 隐藏 `x`，获取初始值并加 `1`，这样 `x` 的值就变成 `6` 了。
* 第三个 `let` 语句也隐藏了 `x`，将之前的值乘以 `2`，`x` 最终的值是 `12`。

## 隐藏与将变量标记为 `mut` 是有区别的

隐藏与将变量标记为 `mut` 是有区别的。

当不小心尝试对变量重新赋值时，如果没有使用 `let` 关键字，就会导致编译时错误。

通过使用 `let`，我们可以用这个值进行一些计算，不过计算完之后变量仍然是不变的。

`mut` 与隐藏的另一个区别是，当再次使用 `let` 时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字。

### 示例

* 例如，假设程序请求用户输入空格字符来说明希望在文本之间显示多少个空格，然而我们真正需要的是将输入存储成数字（多少个空格）
* 这里允许第一个 `spaces` 变量是字符串类型，而第二个 `spaces` 变量，它是一个恰巧与第一个变量同名的崭新变量，是数字类型。
* 隐藏使我们不必使用不同的名字，如 `spaces_str` 和 `spaces_num`；
* 相反，我们可以复用 `spaces` 这个更简单的名字。

```rust
fn main(){
    let spaces = "   ";
    let spaces = spaces.len();
    println!("The value of spaces is: {}", spaces);
    //The value of spaces is: 3
}
```

* 然而，如果尝试使用 `mut`，将会得到一个编译时错误。
* 这个错误说明，我们不能改变变量的类型。
* ![image-20231015233609422](http://qny.expressisland.cn/dian/image-20231015233609422.png)

```rust
//错误
fn main(){
    let mut spaces = "   ";
    spaces = spaces.len();
    println!("The value of spaces is: {}", spaces);
}
```

# 数据类型

* 在 Rust 中，每一个值都属于某一个 **数据类型**（*data type*），这告诉 Rust 它被指定为何种数据，以便明确数据处理方式。

* 我们将看到两类数据类型子集：`标量（scalar）`和 `复合（compound）`。

* 记住，Rust 是 **静态类型**（*statically typed*）语言，也就是说在编译时就必须知道所有变量的类型。

* 根据值及其使用方式，编译器通常可以推断出我们想要用的类型。

* 当多种类型均有可能时，比如猜数字游戏使用 `parse` 将 `String` 转换为数字时，必须增加类型注解。

* `let guess: u32 = "42".parse().expect("Not a number!");`

这里如果不添加类型注解，Rust 会显示如下错误，这说明编译器需要我们提供更多信息，来了解我们想要的类型：

```rust
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
```

## 标量类型

**标量**（*scalar*）类型代表一个单独的值。

Rust 有四种基本的标量类型：**整型、浮点型、布尔类型和字符类型**。

### 整型

**整数** 是一个没有小数部分的数字。

该类型声明表明，它关联的值应该是一个占据 32 比特位的无符号整数（有符号整数类型以 `i` 开头而不是 `u`）。

表格展示了 Rust 内建的整数类型。

在有符号列和无符号列中的每一个变体（例如，`i16`）都可以用来声明整数值的类型。

| 长度    | 有符号  | 无符号  |
| ------- | ------- | ------- |
| 8-bit   | `i8`    | `u8`    |
| 16-bit  | `i16`   | `u16`   |
| 32-bit  | `i32`   | `u32`   |
| 64-bit  | `i64`   | `u64`   |
| 128-bit | `i128`  | `u128`  |
| arch    | `isize` | `usize` |

每一个变体都可以是有符号或无符号的，并有一个明确的大小。

**有符号** 和 **无符号** 代表数字能否为负值，换句话说，数字是否需要有一个符号（有符号数），或者永远为正而不需要符号（无符号数）。

每一个有符号的变体可以储存包含从 -(2n - 1) 到 2n - 1 - 1 在内的数字，这里 *n* 是变体使用的位数。

所以 `i8` 可以储存从 -(27) 到 27 - 1 在内的数字，也就是从 -128 到 127。

无符号的变体可以储存从 0 到 2n - 1 的数字，所以 `u8` 可以储存从 0 到 28 - 1 的数字，也就是从 0 到 255。

另外，`isize` 和 `usize` 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。

注意除 byte 以外的所有数字字面值允许使用类型后缀，例如 `57u8`，同时也允许使用 `_` 做为分隔符以方便读数，例如`1_000`。

#### Rust 中的整型字面值

| 数字字面值       | 例子          |
| ---------------- | ------------- |
| Decimal          | `98_222`      |
| Hex              | `0xff`        |
| Octal            | `0o77`        |
| Binary           | `0b1111_0000` |
| Byte (`u8` only) | `b'A'`        |

#### 那么该使用哪种类型的数字呢？

* 如果拿不定主意，Rust 的默认类型通常就很好。
* 数字类型默认是 `i32`：它通常是最快的，甚至在 64 位系统上也是。
* `isize` 或 `usize` 主要作为某些集合的索引。

> ##### 整型溢出
>
> 比方说有一个 `u8` ，它可以存放从零到 `255` 的值。
>
> 那么当你将其修改为 `256` 时会发生什么呢？这被称为 “整型溢出”（“integer overflow” ）。
>
> 关于这一行为 Rust 有一些有趣的规则。当在 debug 模式编译时，Rust 检查这类问题并使程序 *panic*，这个术语被 Rust 用来表明程序因错误而退出。
>
> 在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码包装（*two’s complement wrapping*）的操作。
>
> 简而言之，`256` 变成 `0`，`257` 变成 `1`，依此类推。
>
> 依赖整型溢出被认为是一种错误，即便可能出现这种行为。
>
> 如果你确实需要这种行为，标准库中有一个类型显式提供此功能，[`Wrapping`](https://rust.bootcss.com/std/num/struct.Wrapping.html)。

### 浮点型

Rust 也有两个原生的 **浮点数**（*floating-point numbers*）类型，它们是带小数点的数字。

Rust 的浮点数类型是 `f32` 和 `f64`，分别占 32 位和 64 位。

默认类型是 `f64`，因为在现代 CPU 中，它与 `f32` 速度几乎一样，不过精度更高。

#### 展示浮点数的实例

* 浮点数采用 IEEE-754 标准表示。
* `f32` 是单精度浮点数，`f64` 是双精度浮点数。

```rust
//展示浮点数的实例
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

### 数值运算

Rust 中的所有数字类型都支持基本数学运算：**加法、减法、乘法、除法和取余**。

下面的代码展示了如何在 `let` 语句中使用它们：

这些语句中的每个表达式使用了一个数学运算符并计算出了一个值，然后绑定给一个变量。

```rust
//数值运算
fn main() {
    // 加法
    let sum = 5 + 10;
    println!("The value of sum is: {}", sum);

    // 减法
    let difference = 95.5 - 4.3;
    println!("The value of difference is: {}", difference);

    // 乘法
    let product = 4 * 30;
    println!("The value of product is: {}", product);

    // 除法
    let quotient = 56.7 / 32.2;
    println!("The value of quotient is: {}", quotient);

    // 取余
    let remainder = 43 % 5;
    println!("The value of remainder is: {}", remainder);

}
```

#### Rust 提供的所有运算符的列表

* https://rust.bootcss.com/appendix-02-operators.html

### 布尔型

Rust 中的布尔类型有两个可能的值：`true` 和 `false`。

使用布尔值的主要场景是条件表达式，例如 `if` 表达式。

Rust 中的布尔类型使用 `bool` 表示。例如：

```rust
//布尔型
fn main() {
    let t = true;
    let f: bool = false; // 显式指定类型注解
}
```

### 字符类型

Rust 也支持字母。

Rust 的 `char` 类型是语言中最原生的字母类型

注意 `char` 由单引号指定，不同于字符串使用双引号。

![image-20231015235405061](http://qny.expressisland.cn/dian/image-20231015235405061.png)

Rust 的 `char` 类型的大小为四个字节(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。

在 Rust 中，拼音字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 `char` 值。

Unicode 标量值包含从 `U+0000` 到 `U+D7FF` 和 `U+E000` 到 `U+10FFFF` 在内的值。不过，“字符” 并不是一个 Unicode 中的概念，所以人直觉上的 “字符” 可能与 Rust 中的 `char` 并不符合。

## 复合类型

**复合类型**（*Compound types*）可以将多个值组合成一个类型。

Rust 有两个原生的复合类型：**元组（tuple）和 数组（array）**。

### 元组类型

元组是一个将多个其他类型的值组合进一个复合类型的主要方式。

元组长度固定：**一旦声明，其长度不会增大或缩小**。

我们使用包含在圆括号中的逗号分隔的值列表来创建一个元组。

元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。

#### 可选的类型注解

```rust
//复合类型 - 元组类型 - 可选的类型注解
fn main(){
    let tup:(i32,f64,u8) = (500,6.4,1);
}
```

`tup` 变量绑定到整个元组上，因为元组是一个单独的复合元素。

#### 使用模式匹配（pattern matching）来解构（destructure）元组值

为了从元组中获取单个值，可以使用模式匹配（pattern matching）来解构（destructure）元组值。

程序首先创建了一个元组并绑定到 `tup` 变量上。

接着使用了 `let` 和一个模式将 `tup` 分成了三个不同的变量，`x`、`y` 和 `z`。

这叫做 **解构**（*destructuring*），因为它将一个元组拆成了三个部分。

最后，程序打印出了 `y` 的值，也就是 `6.4`。

```rust
//为了从元组中获取单个值
//，可以使用模式匹配（pattern matching）来解构（destructure）元组值。
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```

#### 使用点号（`.`）后跟值的索引来直接访问

* 这个程序创建了一个元组，`x`，并接着使用索引为每个元素创建新变量。
* 跟大多数编程语言一样，**元组的第一个索引值是 0**。

```rust
//使用点号（.）后跟值的索引来直接访问
fm main(){
    let x: (i32, f64, u8) = (500, 6.4, 1);
    let fh = x.0;
    let spf = x.1;
    let one = x.2;
}
```

### 数组类型

另一个包含多个值的方式是 **数组**（*array*）。

与元组不同，数组中的每个元素的类型必须相同。

Rust 中的数组与一些其他语言中的数组不同，因为 Rust 中的数组是固定长度的：**一旦声明，它们的长度不能增长或缩小**。

Rust 中，数组中的值位于中括号内的逗号分隔的列表中：

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

当你想要在栈（stack）而不是在堆（heap）上为数据分配空间，或者是想要确保总是有固定数量的元素时，数组非常有用。

但是数组并不如 vector 类型灵活。

vector 类型是标准库提供的一个 **允许** 增长和缩小长度的类似数组的集合类型。

当不确定是应该使用数组还是 vector 的时候，你可能应该使用 vector。

#### 想要使用数组而不是 vector 的例子

* 当程序需要知道一年中月份的名字时，程序不大可能会去增加或减少月份。
* 这时你可以使用数组，因为我们知道它总是包含 12 个元素

```rust
fn main(){
    let months = ["January", "February", "March", "April",
     "May", "June", "July","August",
      "September", "October", "November", "December"];
}
```

#### 另一种写法

* 在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量。
* `i32` 是每个元素的类型。
* 分号之后，数字 `5` 表明该数组包含五个元素。

```rust
fn main(){
    let a: [i32;5] = [1, 2, 3, 4, 5];
}
```

#### 另一个初始化数组的语法

如果你希望创建一个每个元素都相同的数组，可以在中括号内指定其初始值，后跟分号，再后跟数组的长度。

```rust
let a = [3; 5];
```

#### 访问数组元素

数组是一整块分配在栈上的内存。可以使用索引来访问数组的元素。

叫做 `first` 的变量的值是 `1`，因为它是数组索引 `[0]` 的值。变量 `second` 将会是数组索引 `[1]` 的值 `2`。

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

#### 无效的数组元素访问

访问数组结尾之后的元素，编译不过，在运行时会因错误而退出。

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);
}
```

使用 `cargo run` 运行代码后会产生如下结果：

![image-20231016000912623](http://qny.expressisland.cn/dian/image-20231016000912623.png)

* 编译并没有产生任何错误，不过程序会出现一个 **运行时**（*runtime*）错误并且不会成功退出。
* 当尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。如果索引超出了数组长度，Rust 会 *panic*，这是 Rust 术语，它用于程序因为错误而退出的情况。

<u>这是第一个在实战中遇到的 Rust 安全原则的例子。</u>

<u>在很多底层语言中，并没有进行这类检查，这样当提供了一个不正确的索引时，就会访问无效的内存。</u>

<u>通过立即退出而不是允许内存访问并继续执行，Rust 让你避开此类错误。</u>
